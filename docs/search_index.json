[
["index.html", "R, Databases &amp; SQL Preface Structure of the book Software information", " R, Databases &amp; SQL Aravind Hebbali 2020-06-20 Preface This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. Structure of the book Chapter 1 introduces the DBI package. Chapter 2 explores data wrangling within database using the dplyr package. Chapters 3 and 4 introduce basic and advanced SQL Software information The R session information when compiling this book is shown below: sessionInfo() ## R version 4.0.0 (2020-04-24) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 18362) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=English_India.1252 LC_CTYPE=English_India.1252 ## [3] LC_MONETARY=English_India.1252 LC_NUMERIC=C ## [5] LC_TIME=English_India.1252 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached): ## [1] compiler_4.0.0 magrittr_1.5 bookdown_0.18 tools_4.0.0 ## [5] htmltools_0.4.0 rstudioapi_0.11 yaml_2.2.1 Rcpp_1.0.4.6 ## [9] stringi_1.4.6 rmarkdown_2.1 knitr_1.27 stringr_1.4.0 ## [13] xfun_0.13 digest_0.6.25 rlang_0.4.6 evaluate_0.14 We do not add prompts (&gt; and +) to R source code in this book, and we comment out the text output with two hashes ## by default, as you can see from the R session information above. This is for your convenience when you want to copy and run the code (the text output will be ignored since it is commented out). Package names are in bold text (e.g., rmarkdown), and function names are followed by parentheses (e.g., bookdown::render_book()). The double-colon operator :: means accessing an object from a package. "],
["about-the-author.html", "About the Author", " About the Author Aravind Hebbali is the founder of Rsquared Academy. He earned his Masters in Economics from Madras School of Economics. As an active R user, he has authored several R packages such as olsrr rfm descriptr blorr xplorerr In 2015, he founded Rsquared Academy, a free and open source education initiative with focus on data science and analytics. Apart from self paced online courses, Rsquared Academy offers customized learning modules for corporates and universities. You can find him on GitHub. "],
["dbi.html", "Chapter 1 DBI 1.1 Introduction 1.2 Connection 1.3 Querying Data 1.4 Query 1.5 Create Table 1.6 Append Data 1.7 Insert Rows 1.8 Remove Table 1.9 SQLite Data Type 1.10 Close Connection", " Chapter 1 DBI 1.1 Introduction In this chapter, we will learn to: connect to a SQLite database from R display database information list tables in the database query data read entire table read few rows read data in batches create table in database overwrite table in database append data to table in database remove table from database generate SQL query close database connection We will use the following R packages: DBI RSQLite All the data sets used in this chapter can be found here and code can be downloaded from here. 1.2 Connection The first step is to connect to a database. We will connect to an in memory SQLite databse using dbConnect(). con &lt;- dbConnect(RSQLite::SQLite(), &quot;:memory:&quot;) 1.2.1 Connection Summary We can get the more information about the connection using summary(). summary(con) ## Length Class Mode ## 1 SQLiteConnection S4 1.2.2 List Tables Now that we are connected to a database, let us list all the tables present in it using dbListTables(). dbListTables(con) ## [1] &quot;ecom&quot; &quot;sqlite_stat1&quot; &quot;sqlite_stat4&quot; 1.2.3 List Fields Time to explore the ecom table in the database. Use dbListFields() to list all the fields in the table. dbListFields(con, &quot;ecom&quot;) ## [1] &quot;referrer&quot; &quot;device&quot; &quot;bouncers&quot; &quot;n_visit&quot; &quot;n_pages&quot; &quot;duration&quot; 1.3 Querying Data The main objectives of connecting to a database are to: query data from the tables already present create new tables overwrite existing tables delete existing tables Let us begin with querying data. We can do this in the following ways: read an entire table at once read few rows from a table read data in batches 1.3.1 Entire Table We can read an entire table from a database using dbReadTable(). dbReadTable(con, &#39;ecom&#39;) ## referrer device bouncers n_visit n_pages duration ## 1 google laptop 1 10 1 693 ## 2 yahoo tablet 1 9 1 459 ## 3 direct laptop 1 0 1 996 ## 4 bing tablet 0 3 18 468 ## 5 yahoo mobile 1 9 1 955 ## 6 yahoo laptop 0 5 5 135 ## 7 yahoo mobile 1 10 1 75 ## 8 direct mobile 1 10 1 908 ## 9 bing mobile 0 3 19 209 ## 10 google mobile 1 6 1 208 ## 11 direct laptop 1 9 1 738 ## 12 direct tablet 0 6 12 132 ## 13 direct mobile 0 9 14 406 ## 14 yahoo tablet 0 5 8 80 ## 15 yahoo mobile 0 7 1 19 ## 16 bing laptop 1 1 1 995 ## 17 bing tablet 0 5 16 368 ## 18 google tablet 1 7 1 406 ## 19 social tablet 0 7 10 290 ## 20 social tablet 0 2 1 28 In some cases, we may not need the entire table but only a specific number of rows. Use dbGetQuery() and supply a SQL statement specifying the number of rows of data to be read from the table. In the below example, we read ten rows of data from the ecom table. 1.3.2 Few Rows dbGetQuery(con, &quot;select * from ecom limit 10&quot;) ## referrer device bouncers n_visit n_pages duration ## 1 google laptop 1 10 1 693 ## 2 yahoo tablet 1 9 1 459 ## 3 direct laptop 1 0 1 996 ## 4 bing tablet 0 3 18 468 ## 5 yahoo mobile 1 9 1 955 ## 6 yahoo laptop 0 5 5 135 ## 7 yahoo mobile 1 10 1 75 ## 8 direct mobile 1 10 1 908 ## 9 bing mobile 0 3 19 209 ## 10 google mobile 1 6 1 208 In case of very large table, we can read data in batches using dbSendQuery() and dbFetch(). We can mention the number of rows of data to be read while fetching the data using the query generated by dbGetQuery(). 1.3.3 Read Data in Batches query &lt;- dbSendQuery(con, &#39;select * from ecom&#39;) result &lt;- dbFetch(query, n = 15) result ## referrer device bouncers n_visit n_pages duration ## 1 google laptop 1 10 1 693 ## 2 yahoo tablet 1 9 1 459 ## 3 direct laptop 1 0 1 996 ## 4 bing tablet 0 3 18 468 ## 5 yahoo mobile 1 9 1 955 ## 6 yahoo laptop 0 5 5 135 ## 7 yahoo mobile 1 10 1 75 ## 8 direct mobile 1 10 1 908 ## 9 bing mobile 0 3 19 209 ## 10 google mobile 1 6 1 208 ## 11 direct laptop 1 9 1 738 ## 12 direct tablet 0 6 12 132 ## 13 direct mobile 0 9 14 406 ## 14 yahoo tablet 0 5 8 80 ## 15 yahoo mobile 0 7 1 19 1.4 Query 1.4.1 Query Status To know the status of a query, use dbHasCompleted(). It is very useful in cases of queries that might take a long time to complete. dbHasCompleted(query) ## [1] FALSE 1.4.2 Query Info dbGetInfo() will return the following: the sql staement number of rows fetched number of rows modified/affected status of the query dbGetInfo(query) ## $statement ## [1] &quot;select * from ecom&quot; ## ## $row.count ## [1] 15 ## ## $rows.affected ## [1] 0 ## ## $has.completed ## [1] FALSE 1.4.3 Latest Query To get the latest query, use dbGetStatement(). dbGetStatement(query) ## [1] &quot;select * from ecom&quot; 1.4.4 Rows Fetched To check the number of rows of data returned by a query, use dbGetRowCount(). dbGetRowCount(query) ## [1] 15 1.4.5 Rows Affected To know the number of rows modified or affected in the table, use dbGetRowsAffected(). dbGetRowsAffected(query) ## [1] 0 1.4.6 Column Info To know the name of the columns and their data types, use dbColumnInfo(). dbColumnInfo(query) ## name type ## 1 referrer character ## 2 device character ## 3 bouncers integer ## 4 n_visit double ## 5 n_pages double ## 6 duration double 1.5 Create Table So far we have explored querying data from an existing table. Now, let us turn our attention to creating new tables in the database. 1.5.0.1 Introduction To create a new table, use dbWriteTable(). It takes the following 3 arguments: connection name name of the new table data for the new table x &lt;- 1:10 y &lt;- letters[1:10] trial &lt;- tibble::tibble(x, y) dbWriteTable(con, &quot;trial&quot;, trial) ## Warning: Closing open result set, pending rows Let us check if the new table has been created. dbListTables(con) ## [1] &quot;ecom&quot; &quot;sqlite_stat1&quot; &quot;sqlite_stat4&quot; &quot;trial&quot; dbExistsTable(con, &quot;trial&quot;) ## [1] TRUE Let us query data from the new table. dbGetQuery(con, &quot;select * from trial limit 5&quot;) ## x y ## 1 1 a ## 2 2 b ## 3 3 c ## 4 4 d ## 5 5 e 1.5.0.2 Overwrite Table In some cases, you may want to overwrite the data in an existing table. Use the overwrite argument in dbWriteTable() and set it to TRUE. x &lt;- sample(100, 10) y &lt;- letters[11:20] trial2 &lt;- tibble::tibble(x, y) dbWriteTable(con, &quot;trial&quot;, trial2, overwrite = TRUE) Let us see if the trial table has been overwritten. dbGetQuery(con, &quot;select * from trial limit 5&quot;) ## x y ## 1 59 k ## 2 72 l ## 3 94 m ## 4 24 n ## 5 30 o 1.6 Append Data You can append data to an existing table by setting the append argument in dbWriteTable() to TRUE. x &lt;- sample(100, 10) y &lt;- letters[5:14] trial3 &lt;- tibble::tibble(x, y) dbWriteTable(con, &quot;trial&quot;, trial3, append = TRUE) Let us quickly check if the new data has been appended to the trial table. dbReadTable(con, &quot;trial&quot;) ## x y ## 1 59 k ## 2 72 l ## 3 94 m ## 4 24 n ## 5 30 o ## 6 29 p ## 7 43 q ## 8 66 r ## 9 84 s ## 10 32 t ## 11 86 e ## 12 89 f ## 13 80 g ## 14 71 h ## 15 25 i ## 16 16 j ## 17 43 k ## 18 10 l ## 19 11 m ## 20 75 n We can also use sqlAppendTable() to append data to an existing table. sqlAppendTable(con, &quot;ecom&quot;, head(ecom)) ## Warning: Do not rely on the default value of the row.names argument for ## sqlAppendTable(), it will change in the future. ## &lt;SQL&gt; INSERT INTO `ecom` ## (`referrer`, `device`, `bouncers`, `n_visit`, `n_pages`, `duration`) ## VALUES ## (&#39;google&#39;, &#39;laptop&#39;, TRUE, 10, 1, 693), ## (&#39;yahoo&#39;, &#39;tablet&#39;, TRUE, 9, 1, 459), ## (&#39;direct&#39;, &#39;laptop&#39;, TRUE, 0, 1, 996), ## (&#39;bing&#39;, &#39;tablet&#39;, FALSE, 3, 18, 468), ## (&#39;yahoo&#39;, &#39;mobile&#39;, TRUE, 9, 1, 955), ## (&#39;yahoo&#39;, &#39;laptop&#39;, FALSE, 5, 5, 135) 1.7 Insert Rows 1.7.0.1 Introduction We can insert new rows into existing tables using: dbExecute() dbSendStatement() Both the function take 2 arguments: connection name sql statement # use dbExecute dbExecute(con, &quot;INSERT into trial (x, y) VALUES (32, &#39;c&#39;), (45, &#39;k&#39;), (61, &#39;h&#39;)&quot; ) ## [1] 3 # use dbSendStatement dbSendStatement(con, &quot;INSERT into trial (x, y) VALUES (25, &#39;m&#39;), (54, &#39;l&#39;), (16, &#39;y&#39;)&quot; ) ## &lt;SQLiteResult&gt; ## SQL INSERT into trial (x, y) VALUES (25, &#39;m&#39;), (54, &#39;l&#39;), (16, &#39;y&#39;) ## ROWS Fetched: 0 [complete] ## Changed: 3 1.8 Remove Table If you want to delete/remove a table from the database, use dbRemoveTable(). dbRemoveTable(con, &quot;trial&quot;) ## Warning: Closing open result set, pending rows 1.9 SQLite Data Type If you want to know the data type, use dbDataType(). dbDataType(RSQLite::SQLite(), &quot;a&quot;) ## [1] &quot;TEXT&quot; dbDataType(RSQLite::SQLite(), 1:5) ## [1] &quot;INTEGER&quot; dbDataType(RSQLite::SQLite(), 1.5) ## [1] &quot;REAL&quot; 1.10 Close Connection It is a good practice to close connection to a database when you no longer need to read/write data from/to it. Use dbDisconnect() to close the database connection. dbDisconnect(con) "],
["dbplyr.html", "Chapter 2 dbplyr 2.1 Introduction 2.2 Connect to Database 2.3 Reference Data 2.4 Query Data 2.5 Show Query 2.6 Collect Data", " Chapter 2 dbplyr 2.1 Introduction In this chapter, we will learn to query data from a database using dplyr. We will use the following R packages: DBI RSQLite dbplyr dplyr All the data sets used in this chapter can be found here and code can be downloaded from here. 2.2 Connect to Database Let us connect to an in memory SQLite database using dbConnect(). con &lt;- dbConnect(RSQLite::SQLite(), &quot;:memory:&quot;) We will copy the mtcars data to the database so that we can use it for running dplyr statements. dplyr::copy_to(con, mtcars) 2.3 Reference Data In order to use dplyr functions, we need to reference the table in the database using tbl(). mtcars2 &lt;- dplyr::tbl(con, &quot;mtcars&quot;) mtcars2 ## # Source: table&lt;mtcars&gt; [?? x 11] ## # Database: sqlite 3.30.1 [:memory:] ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # ... with more rows 2.4 Query Data We will look at some simple examples. Let us start by selecting mpg, cyl and drat columns from mtcars2. select(mtcars2, mpg, cyl, drat) ## # Source: lazy query [?? x 3] ## # Database: sqlite 3.30.1 [:memory:] ## mpg cyl drat ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 3.9 ## 2 21 6 3.9 ## 3 22.8 4 3.85 ## 4 21.4 6 3.08 ## 5 18.7 8 3.15 ## 6 18.1 6 2.76 ## 7 14.3 8 3.21 ## 8 24.4 4 3.69 ## 9 22.8 4 3.92 ## 10 19.2 6 3.92 ## # ... with more rows We can filter data as well. Filter all the rows from mtcars2 where mpg is greater than 25. filter(mtcars2, mpg &gt; 25) ## # Source: lazy query [?? x 11] ## # Database: sqlite 3.30.1 [:memory:] ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 32.4 4 78.7 66 4.08 2.2 19.5 1 1 4 1 ## 2 30.4 4 75.7 52 4.93 1.62 18.5 1 1 4 2 ## 3 33.9 4 71.1 65 4.22 1.84 19.9 1 1 4 1 ## 4 27.3 4 79 66 4.08 1.94 18.9 1 1 4 1 ## 5 26 4 120. 91 4.43 2.14 16.7 0 1 5 2 ## 6 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 Time to do some grouping and summarizing. Let us compute the average mileage for different types of cylinders. mtcars2 %&gt;% group_by(cyl) %&gt;% summarise(mileage = mean(mpg)) ## Warning: Missing values are always removed in SQL. ## Use `mean(x, na.rm = TRUE)` to silence this warning ## This warning is displayed only once per session. ## # Source: lazy query [?? x 2] ## # Database: sqlite 3.30.1 [:memory:] ## cyl mileage ## &lt;dbl&gt; &lt;dbl&gt; ## 1 4 26.7 ## 2 6 19.7 ## 3 8 15.1 2.5 Show Query If you want to view the SQL query generated in the above step, use show_query() or explain(). mileages &lt;- mtcars2 %&gt;% group_by(cyl) %&gt;% summarise(mileage = mean(mpg)) dplyr::show_query(mileages) ## &lt;SQL&gt; ## SELECT `cyl`, AVG(`mpg`) AS `mileage` ## FROM `mtcars` ## GROUP BY `cyl` dplyr::explain(mileages) ## &lt;SQL&gt; ## SELECT `cyl`, AVG(`mpg`) AS `mileage` ## FROM `mtcars` ## GROUP BY `cyl` ## ## &lt;PLAN&gt; ## id parent notused detail ## 1 6 0 0 SCAN TABLE mtcars ## 2 8 0 0 USE TEMP B-TREE FOR GROUP BY 2.6 Collect Data Now, some interesting facts. When working with databases, dplyr never pulls data into R unless you explicitly ask for it. In the previous example, dplyr will not do anything until you ask for the mileages data. It generates the SQL and only pulls down a few rows when you try to print mileages. So how do we pull all the data and store it for further analysis? collect() will pull all the data and store it in a tibble and you can use it for any further analysis. dplyr::collect(mileages) ## # A tibble: 3 x 2 ## cyl mileage ## &lt;dbl&gt; &lt;dbl&gt; ## 1 4 26.7 ## 2 6 19.7 ## 3 8 15.1 "],
["sqlbasics.html", "Chapter 3 SQL Basics 3.1 Introduction 3.2 Set Up 3.3 Select Columns 3.4 Limit 3.5 Distinct 3.6 Filter 3.7 And, Or &amp; Not 3.8 BETWEEN 3.9 IN 3.10 IS NULL 3.11 LIKE", " Chapter 3 SQL Basics 3.1 Introduction In this chapter, we will learn to: select single column multiple columns distinct values in a column limit the number of records returned handle NULL values and filter columns using the following operators WHERE AND, or &amp; NOT BETWEEN IN LIKE We will use the following R packages: DBI RSQLite dbplyr All the data sets used in this chapter can be found here and code can be downloaded from here. 3.2 Set Up In order to be able to use the ecom data set for our case study, we will read it using the readr package and then copy it to an in memory database using the copy_to() function from dplyr. ecom &lt;- readr::read_csv(&#39;https://raw.githubusercontent.com/rsquaredacademy/datasets/master/web.csv&#39;) con &lt;- DBI::dbConnect(RSQLite::SQLite(), &quot;:memory:&quot;) copy_to(con, ecom) 3.3 Select Columns The SQL SELECT statement is used to fetch the data from a database table. 3.3.1 Syntax Below is the basic syntax of the SELECT statement. SELECT column1, column2, columnN FROM table_name; Here, column1, column2… are the fields of a table whose values you want to fetch. If you want to fetch all the fields, use the following syntax. SELECT * FROM table_name; 3.3.2 Select Single Column Let us begin by selecting the device field from the ecom table. SELECT device FROM ecom Table 3.1: Displaying records 1 - 10 device laptop tablet laptop tablet mobile laptop mobile mobile mobile mobile 3.3.3 Select Multiple Columns Select the following fields from the ecom table: referrer device purchase SELECT referrer, device, purchase FROM ecom Table 3.2: Displaying records 1 - 10 referrer device purchase google laptop 0 yahoo tablet 0 direct laptop 0 bing tablet 1 yahoo mobile 0 yahoo laptop 0 yahoo mobile 0 direct mobile 0 bing mobile 0 google mobile 0 3.3.4 Select All Columns Select all the fields from the ecom table. SELECT * FROM ecom Table 3.3: Displaying records 1 - 10 id referrer device bouncers n_visit n_pages duration country purchase order_items order_value 1 google laptop 1 10 1 693 Czech Republic 0 0 0 2 yahoo tablet 1 9 1 459 Yemen 0 0 0 3 direct laptop 1 0 1 996 Brazil 0 0 0 4 bing tablet 0 3 18 468 China 1 6 434 5 yahoo mobile 1 9 1 955 Poland 0 0 0 6 yahoo laptop 0 5 5 135 South Africa 0 0 0 7 yahoo mobile 1 10 1 75 Bangladesh 0 0 0 8 direct mobile 1 10 1 908 Indonesia 0 0 0 9 bing mobile 0 3 19 209 Netherlands 0 0 0 10 google mobile 1 6 1 208 Czech Republic 0 0 0 3.4 Limit If you have a large table with thousands of rows, returning all the records will take time. Use LIMIT to specify the number of records to return. SELECT * FROM ecom limit 10 Table 3.4: Displaying records 1 - 10 id referrer device bouncers n_visit n_pages duration country purchase order_items order_value 1 google laptop 1 10 1 693 Czech Republic 0 0 0 2 yahoo tablet 1 9 1 459 Yemen 0 0 0 3 direct laptop 1 0 1 996 Brazil 0 0 0 4 bing tablet 0 3 18 468 China 1 6 434 5 yahoo mobile 1 9 1 955 Poland 0 0 0 6 yahoo laptop 0 5 5 135 South Africa 0 0 0 7 yahoo mobile 1 10 1 75 Bangladesh 0 0 0 8 direct mobile 1 10 1 908 Indonesia 0 0 0 9 bing mobile 0 3 19 209 Netherlands 0 0 0 10 google mobile 1 6 1 208 Czech Republic 0 0 0 3.5 Distinct A column in a table may often contain many duplicate values; and we might be interested only in the distinct/unique values. In such cases, we can use the SELECT DISTINCT statement to return only distinct values. SELECT distinct referrer FROM ecom Table 3.5: 5 records referrer google yahoo direct bing social 3.6 Filter Now that we know how to select columns, let us focus on filtering data. In SQL, the WHERE keyword is used to extract only those records that fulfill a specified condition. Data filter based on both text and numeric values in a table. Below are a few comparison operators we can use: = equal &lt;&gt; not equal &lt; less than &gt; greater than &lt;= less than or equal to &gt;= greater than or equal to The following SQL statement filters all rows from the ecom table where the duration field is greater than 300. SELECT * FROM ecom WHERE duration &gt; 300 Table 3.6: Displaying records 1 - 10 id referrer device bouncers n_visit n_pages duration country purchase order_items order_value 1 google laptop 1 10 1 693 Czech Republic 0 0 0 2 yahoo tablet 1 9 1 459 Yemen 0 0 0 3 direct laptop 1 0 1 996 Brazil 0 0 0 4 bing tablet 0 3 18 468 China 1 6 434 5 yahoo mobile 1 9 1 955 Poland 0 0 0 8 direct mobile 1 10 1 908 Indonesia 0 0 0 11 direct laptop 1 9 1 738 Jamaica 0 0 0 13 direct mobile 0 9 14 406 Ireland 1 3 651 16 bing laptop 1 1 1 995 United States 0 0 0 17 bing tablet 0 5 16 368 Peru 1 6 1049 Let us filter data based on a text value. In the following example, we filter all rows from the ecom table where the device used is mobile. SELECT * FROM ecom WHERE device == &#39;mobile&#39; Table 3.7: Displaying records 1 - 10 id referrer device bouncers n_visit n_pages duration country purchase order_items order_value 5 yahoo mobile 1 9 1 955 Poland 0 0 0 7 yahoo mobile 1 10 1 75 Bangladesh 0 0 0 8 direct mobile 1 10 1 908 Indonesia 0 0 0 9 bing mobile 0 3 19 209 Netherlands 0 0 0 10 google mobile 1 6 1 208 Czech Republic 0 0 0 13 direct mobile 0 9 14 406 Ireland 1 3 651 15 yahoo mobile 0 7 1 19 France 0 7 2423 22 google mobile 1 5 1 147 Brazil 0 0 0 23 bing mobile 0 0 7 196 Russia 0 4 237 29 google mobile 1 10 1 338 Russia 0 0 0 3.7 And, Or &amp; Not The WHERE clause can be combined with other operators such as AND - displays a record if all the conditions separated by AND is TRUE OR - displays a record if any of the conditions separated by OR is TRUE NOT - displays a record if the condition(s) is NOT TRUE to filter data based on more than one condition or to create more complex conditions. In the following example, we filter all the rows from the ecom table where n_visit (visit count) is greater than 3 and duration (time spent on the site) is greater than 100. We use AND to create multiple conditions. SELECT * FROM ecom WHERE n_visit &gt; 3 AND duration &gt; 100 Table 3.8: Displaying records 1 - 10 id referrer device bouncers n_visit n_pages duration country purchase order_items order_value 1 google laptop 1 10 1 693 Czech Republic 0 0 0 2 yahoo tablet 1 9 1 459 Yemen 0 0 0 5 yahoo mobile 1 9 1 955 Poland 0 0 0 6 yahoo laptop 0 5 5 135 South Africa 0 0 0 8 direct mobile 1 10 1 908 Indonesia 0 0 0 10 google mobile 1 6 1 208 Czech Republic 0 0 0 11 direct laptop 1 9 1 738 Jamaica 0 0 0 12 direct tablet 0 6 12 132 Estonia 0 0 0 13 direct mobile 0 9 14 406 Ireland 1 3 651 17 bing tablet 0 5 16 368 Peru 1 6 1049 In the next example, we will use both AND &amp; OR. Our goal is to filter all rows from the ecom table that follow the below conditions: n_visit (visit count) is either equal to 3 or 5 device used to visit the website is either mobile or tablet SELECT * FROM ecom WHERE (n_visit == 5 OR n_visit == 3) AND (device = &#39;mobile&#39; OR device = &#39;tablet&#39;) Table 3.9: Displaying records 1 - 10 id referrer device bouncers n_visit n_pages duration country purchase order_items order_value 4 bing tablet 0 3 18 468 China 1 6 434 9 bing mobile 0 3 19 209 Netherlands 0 0 0 14 yahoo tablet 0 5 8 80 Philippines 0 2 362 17 bing tablet 0 5 16 368 Peru 1 6 1049 22 google mobile 1 5 1 147 Brazil 0 0 0 38 yahoo mobile 1 3 1 700 Canada 0 0 0 50 bing tablet 1 5 1 831 Iran 0 0 0 53 social tablet 0 3 12 324 China 0 0 0 64 yahoo tablet 0 3 5 140 Latvia 0 6 2798 67 yahoo tablet 1 3 1 332 France 0 0 0 3.8 BETWEEN The BETWEEN operator selects values within a given range and is inclusive: begin and end values are included. The values can be numbers, text, or dates. In the following example, we filter rows from the ecom table where the visit count is between 1 and 3, and the device used to visit the website is mobile. SELECT * FROM ecom WHERE n_visit BETWEEN 1 AND 3 AND device = &#39;mobile&#39; Table 3.10: Displaying records 1 - 10 id referrer device bouncers n_visit n_pages duration country purchase order_items order_value 9 bing mobile 0 3 19 209 Netherlands 0 0 0 32 direct mobile 1 2 1 501 El Salvador 0 0 0 36 bing mobile 0 1 1 25 Ireland 0 10 1885 38 yahoo mobile 1 3 1 700 Canada 0 0 0 42 direct mobile 0 1 13 234 Indonesia 0 0 0 49 social mobile 0 1 2 44 France 0 10 1515 98 bing mobile 0 3 18 288 Portugal 1 6 764 99 yahoo mobile 1 1 1 73 Indonesia 0 0 0 102 google mobile 0 2 3 69 Bahamas 0 3 583 105 direct mobile 1 1 1 423 Mexico 0 0 0 3.9 IN The IN operator allows us to specify multiple values in a WHERE clause. It is a shorthand for multiple OR conditions. In the below example, we filter rows from the ecom table where the visit count is either 2 or 4 or 6 or 8 or 10. Instead of using multiple OR conditions, we use the IN operator. SELECT * FROM ecom WHERE n_visit IN (2, 4, 6, 8, 10) Table 3.11: Displaying records 1 - 10 id referrer device bouncers n_visit n_pages duration country purchase order_items order_value 1 google laptop 1 10 1 693 Czech Republic 0 0 0 7 yahoo mobile 1 10 1 75 Bangladesh 0 0 0 8 direct mobile 1 10 1 908 Indonesia 0 0 0 10 google mobile 1 6 1 208 Czech Republic 0 0 0 12 direct tablet 0 6 12 132 Estonia 0 0 0 20 social tablet 0 2 1 28 Namibia 0 7 2077 21 direct laptop 1 2 1 384 China 0 0 0 24 social laptop 1 4 1 850 Ukraine 0 0 0 27 direct tablet 0 2 19 342 Japan 1 5 622 29 google mobile 1 10 1 338 Russia 0 0 0 3.10 IS NULL A field with a NULL value is a field with no value. If a field in a table is optional, it is possible to insert a new record or update a record without adding a value to this field. Then, the field will be saved with a NULL value. In the next example, we filter all rows from the ecom table where the device column has NULL values. SELECT * FROM ecom WHERE device IS NULL Table 3.12: 0 records id referrer device bouncers n_visit n_pages duration country purchase order_items order_value 3.11 LIKE The LIKE operator is used to search for a specific pattern in a column. There are two wildcards used in conjunction with the LIKE operator: % : represents zero, one, or multiple characters _ : represents a single character In the following example, we filter all rows from the ecom table where the name of the country starts with P. We use % after P to indicate that it can be followed by any number or type of characters. SELECT * FROM ecom WHERE country LIKE &#39;P%&#39; Table 3.13: Displaying records 1 - 10 id referrer device bouncers n_visit n_pages duration country purchase order_items order_value 5 yahoo mobile 1 9 1 955 Poland 0 0 0 14 yahoo tablet 0 5 8 80 Philippines 0 2 362 17 bing tablet 0 5 16 368 Peru 1 6 1049 43 bing laptop 1 0 1 456 Portugal 0 0 0 59 yahoo tablet 1 9 1 706 Philippines 0 0 0 62 direct tablet 1 8 1 814 Philippines 0 0 0 72 social laptop 0 5 16 176 Panama 0 5 2216 77 yahoo laptop 1 4 1 928 Peru 0 0 0 88 yahoo tablet 0 3 11 176 Philippines 0 0 0 93 google laptop 1 9 1 869 Poland 0 0 0 Let us look at another example where we filter all rows from the ecom table where the name of the country should follow the below conditions: name can start with any character the second character must be o it can have any type or number of characters after the second character SELECT * FROM ecom WHERE country LIKE &#39;_o%&#39; Table 3.14: Displaying records 1 - 10 id referrer device bouncers n_visit n_pages duration country purchase order_items order_value 5 yahoo mobile 1 9 1 955 Poland 0 0 0 6 yahoo laptop 0 5 5 135 South Africa 0 0 0 19 social tablet 0 7 10 290 Colombia 1 9 1304 30 yahoo mobile 0 8 9 225 Colombia 0 0 0 33 direct laptop 1 8 1 658 Colombia 0 0 0 43 bing laptop 1 0 1 456 Portugal 0 0 0 44 yahoo tablet 0 7 11 264 Somalia 0 0 0 56 google tablet 0 1 19 304 Colombia 0 0 0 93 google laptop 1 9 1 869 Poland 0 0 0 95 social tablet 1 1 1 566 Portugal 0 0 0 "],
["sql2.html", "Chapter 4 SQL Advanced 4.1 Introduction 4.2 Set Up 4.3 Aggregate 4.4 Alias 4.5 Order By 4.6 Group By", " Chapter 4 SQL Advanced 4.1 Introduction In this chapter, we will learn to aggregate data order data and group data We will use the following R packages: DBI RSQLite dbplyr All the data sets used in this chapter can be found here and code can be downloaded from here. 4.2 Set Up In order to be able to use the ecom data set for our case study, we will read it using the readr package and then copy it to an in memory database using the copy_to() function from dplyr. ecom &lt;- readr::read_csv(&#39;https://raw.githubusercontent.com/rsquaredacademy/datasets/master/web.csv&#39;) con &lt;- DBI::dbConnect(RSQLite::SQLite(), &quot;:memory:&quot;) copy_to(con, ecom) 4.3 Aggregate Let us combine the aggregate statements with WHERE statement to filter data. SUM() : returns the total sum of a numeric column SELECT SUM(n_visit) FROM ecom Table 4.1: 1 records SUM(n_visit) 4972 SELECT SUM(n_visit) FROM ecom WHERE n_visit &gt; 5 Table 4.2: 1 records SUM(n_visit) 3574 AVG() : returns the average value of a numeric column SELECT AVG(n_visit) FROM ecom Table 4.3: 1 records AVG(n_visit) 4.972 SELECT AVG(n_visit) FROM ecom WHERE country LIKE &#39;P%&#39; Table 4.4: 1 records AVG(n_visit) 5.07913669064748 MAX() : returns the largest value of the selected column SELECT MAX(n_visit) FROM ecom Table 4.5: 1 records MAX(n_visit) 10 SELECT MAX(n_visit) FROM ecom WHERE device == &#39;tablet&#39; Table 4.6: 1 records MAX(n_visit) 10 MIN() : returns the smallest value of the selected column SELECT MIN(n_visit) FROM ecom Table 4.7: 1 records MIN(n_visit) 0 SELECT MIN(n_visit) FROM ecom WHERE duration BETWEEN 600 AND 900 Table 4.8: 1 records MIN(n_visit) 0 4.4 Alias SQL aliases are used to give a table, or a column in a table, a temporary name. They are often used to make column names more readable. An alias only exists for the duration of the query. Below are a few examples: SELECT AVG(n_visit) AS avg_mobile FROM ecom WHERE device == &#39;mobile&#39; Table 4.9: 1 records avg_mobile 5.4796511627907 SELECT MAX(n_visit) AS max_visit FROM ecom Table 4.10: 1 records max_visit 10 SELECT MIN(duration) AS min_duration FROM ecom Table 4.11: 1 records min_duration 10 4.5 Order By The ORDER BY keyword is used to sort the records in ascending or descending order. By default, the records are sorted in ascending order. Use the DESC keyword if you want to sort the records in descending order, SELECT * FROM ecom ORDER BY country Table 4.12: Displaying records 1 - 10 id referrer device bouncers n_visit n_pages duration country purchase order_items order_value 232 social laptop 0 8 2 60 Afghanistan 0 0 0 299 yahoo laptop 0 10 18 180 Afghanistan 0 0 0 570 social laptop 1 2 1 274 Afghanistan 0 0 0 677 direct tablet 1 10 1 682 Afghanistan 0 0 0 682 direct tablet 0 5 18 414 Afghanistan 1 8 2006 853 bing tablet 0 7 2 34 Afghanistan 0 10 2122 169 direct laptop 0 6 6 96 Albania 0 0 0 423 google laptop 1 5 1 304 Albania 0 0 0 456 bing mobile 0 2 2 54 Albania 0 10 2182 492 yahoo laptop 0 3 1 23 Albania 0 0 0 SELECT * FROM ecom ORDER BY duration Table 4.13: Displaying records 1 - 10 id referrer device bouncers n_visit n_pages duration country purchase order_items order_value 236 yahoo tablet 1 5 1 10 Poland 0 0 0 615 social laptop 1 1 1 10 Finland 0 0 0 392 yahoo laptop 0 0 1 12 Indonesia 0 0 0 688 social mobile 1 2 1 12 Botswana 0 0 0 468 direct laptop 0 0 1 13 Czech Republic 0 5 1598 63 direct mobile 0 10 1 17 China 0 0 0 951 yahoo tablet 0 4 1 17 Poland 0 3 1478 15 yahoo mobile 0 7 1 19 France 0 7 2423 177 bing laptop 0 5 1 20 Thailand 0 3 1252 432 yahoo mobile 0 6 1 21 Russia 0 0 0 SELECT * FROM ecom ORDER BY n_visit DESC Table 4.14: Displaying records 1 - 10 id referrer device bouncers n_visit n_pages duration country purchase order_items order_value 1 google laptop 1 10 1 693 Czech Republic 0 0 0 7 yahoo mobile 1 10 1 75 Bangladesh 0 0 0 8 direct mobile 1 10 1 908 Indonesia 0 0 0 29 google mobile 1 10 1 338 Russia 0 0 0 40 google mobile 1 10 1 479 Cameroon 0 0 0 63 direct mobile 0 10 1 17 China 0 0 0 96 direct tablet 0 10 3 57 China 0 4 722 112 social mobile 0 10 11 242 Argentina 1 4 287 116 direct mobile 1 10 1 675 Indonesia 0 0 0 153 google tablet 1 10 1 86 China 0 0 0 4.6 Group By The GROUP BY statement is used with aggregate functions (COUNT, MAX, MIN, SUM, AVG) to group the result by one or more columns. SELECT device, count(*) AS visits FROM ecom GROUP BY device ORDER by visits DESC Table 4.15: 3 records device visits mobile 344 tablet 331 laptop 325 SELECT device, MAX(duration) AS max_duration FROM ecom GROUP BY device ORDER by max_duration DESC Table 4.16: 3 records device max_duration tablet 999 laptop 997 mobile 994 "]
]
